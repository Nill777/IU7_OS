/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <pthread.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "pc.h"


#define P -1
#define V  1

#define BIN_SEM 0
#define BUFF_FULL 1
#define BUFF_EMPTY 2
 

struct sembuf start_produce[2] = {{BUFF_EMPTY, P, 0}, {BIN_SEM, P, 0}};
struct sembuf stop_produce[2] =  {{BIN_SEM, V, 0}, {BUFF_FULL, V, 0}};
struct sembuf start_consume[2] = {{BUFF_FULL, P, 0}, {BIN_SEM, P, 0}};
struct sembuf stop_consume[2] =  {{BIN_SEM, V, 0}, {BUFF_EMPTY, V, 0}};


char buffer[SIZE_BUF];
char *addr_prod = buffer;
char *addr_cons = buffer;
char letter = 'a';


char producer()
{

    if (semop(semid, start_produce, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop  errno %d", errno);
        perror(err_msg);
        exit(1);
    }


    *(addr_prod) = letter;
    char produced = *(addr_prod);
    printf("Producer -> %c\n", produced);

    if (produced == 'z')
        letter = 'a';
    else
        (letter)++;
    (addr_prod)++;


    if (semop(semid, stop_produce, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }

    return produced;
}

char consumer()
{
    if (semop(semid, start_consume, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }

    char consumed = *(addr_cons);
    (addr_cons)++;
    printf("\tConsumer -> %c\n", consumed);

    if (semop(semid, stop_consume, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }
    return consumed;
}


bool_t
service_1_svc(int *argp, char *result, struct svc_req *rqstp)
{
    if (!argp || !result)
        return FALSE;
    char res_letter;

    if (*argp == 0) {
        res_letter = producer();
        *result = res_letter;
    } else if (*argp == 1) {
        res_letter = *result = consumer();
        *result = res_letter;
    } else {
        return FALSE;
    }

    return TRUE;
}

int
pc_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	return 1;
}